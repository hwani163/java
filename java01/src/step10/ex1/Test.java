package step10.ex1;

//다형적 변수
//- 어떤 타입의 참조 변수가 그 타입의 자손 객체에 대해서도 가리킬 수 있는 것.
//- 용도: 다른 객체로 대체하기가 쉽다.
public class Test {

  public static void main(String[] args) {
    A r1 = new A();
    
    //하위 클래스의 인스턴스를 가리킬 수 있다.
    r1 = new B();
    r1 = new C();
    r1 = new D();
    r1 = new E();
    r1 = new F();
    
    //단, 컴파일 할 때는 어떤 인스턴스를 가리키는가가 중요하지 않고,
    //그 참조 변수가 어떤 클래스의 참조 변수인지가 중요하다.
    //그 클래스 범위에서만 메서드를 호출하거나 인스턴스 변수에 접근할 수 있다.
    r1 = new C();
    r1.m(); // m()은 A 클래스의 메서드이기 때문에 호출 가능! 
    //r1.m3(); // 호출 불가! 비록 r1이 가리키는 것은 C의 인스턴스라 할지라도 
             // 문법 상 r1은 A 클래스이기 때문에 호출 안된다.

    //실제로 가리키는 인스턴스의 메서드를 호출하려면 => 형변환 명령을 사용하라!
    ((C)r1).m3();  //OK!
    
    //인스턴스의 타입을 속였을 때,
    r1 = new A();
    //((C)r1).m3(); //컴파일러는 개발자를 믿고 컴파일 해준다. 실행 오류! 
                  //그러나, JVM은 r1이 실제 어떤 타입의 인스턴스를 가리키는지 알기 때문에
                  //실행할 때 형변환 할 수 없다고 오류를 띄운다. ClassCaseException
    
    
    //다형적 변수의 또 다른 증명
    C r2 = new C(); 
    //항상 자식 클래스의 인스턴스는 가리킬 수 있다.
    // (자식 클래스의 인스턴스 주소를 담을 수 있다.)
    r2 = new D();
    r2 = new E();
    r2 = new F();
    
    //상위 클래스의 인스턴스는 가리킬 수 없다.
    //r2 = new A(); //컴파일 오류!
    
    //형제 클래스의 인스턴스는 가리킬 수 없다.
    //r2 = new B(); //컴파일 오류!
    
    /* 상위 클래스의 인스턴스를 가리킬 수 없는 이유?
     * C r3 = new A(); 가 허용된다면,
     * r3.m3(); 를 시도할 수 있기 때문이다.
     */
  }

}






















